## **Reto: Proyecto de Arte Generativo**

### **Descripci√≥n del proyecto**
Para este reto desarroll√© una aplicaci√≥n de arte generativo usando **C++** y **openFrameworks**.  
La idea fue crear una composici√≥n visual con muchos c√≠rculos que reaccionan de distintas maneras seg√∫n el ‚Äúestado‚Äù en el que se encuentra el sistema: **Calm**, **Active** o **Chaos**.  
Cada estado cambia la forma en que se mueven y los colores que usan los c√≠rculos, dando una sensaci√≥n de energ√≠a o tranquilidad dependiendo del modo.

---

### **C√≥mo us√© los patrones de dise√±o**

#### **Observer**
Us√© este patr√≥n para que los c√≠rculos ‚Äúescuchen‚Äù los cambios del estado general.  
Cuando el programa cambia de modo (por ejemplo, de Calm a Active), todos los c√≠rculos se enteran al mismo tiempo y reaccionan autom√°ticamente.  
Sin embargo, solo en el modo **Calm** los c√≠rculos pueden cambiar de color presionando la tecla **M**.  
Esto lo hice para que cada grupo de c√≠rculos tuviera su propia personalidad y no todos reaccionaran igual.

---

#### **Factory**
Us√© el patr√≥n Factory para crear distintos tipos de c√≠rculos f√°cilmente.  
En total, tengo **tres f√°bricas** diferentes:

1. **ColorCircleFactory:** crea los c√≠rculos del modo **Calm**, que cambian entre tonos verde claro, verde oscuro, aqua y blueViolet.  
2. **NeutralCircleFactory:** crea los c√≠rculos del modo **Active**, que se mueven m√°s r√°pido y tienen tonos **naranja**.  
3. **MotionCircleFactory:** crea los c√≠rculos del modo **Chaos**, que usan el color **crimson** y se mueven con mucha fuerza, casi como si vibraran.  

Gracias a esto, puedo controlar c√≥mo se comportan y c√≥mo se ven dependiendo del modo, sin tener que repetir c√≥digo.

---

#### **State**
Este patr√≥n lo us√© para controlar los tres modos principales del programa.  
Cada modo cambia la forma en que los c√≠rculos se mueven:
- En **Calm**, se mueven suave y lento.  
- En **Active**, aumentan la velocidad y se nota m√°s energ√≠a.  
- En **Chaos**, los movimientos son mucho m√°s bruscos y r√°pidos, como si todo estuviera fuera de control.  

Los modos se pueden cambiar con las teclas:
- **C** ‚Üí Calm  
- **A** ‚Üí Active  
- **X** ‚Üí Chaos  

Tambi√©n se pueden ajustar los niveles de velocidad con los n√∫meros del **1 al 6**, y con clics del mouse los c√≠rculos se reacomodan aleatoriamente.

---

### **Pruebas realizadas**

Durante el desarrollo fui probando constantemente que todo funcionara bien:
- Verifiqu√© que los colores solo cambiaran cuando el programa est√° en modo **Calm** y que no afectaran los otros modos.  
- Revis√© que cada f√°brica generara correctamente sus c√≠rculos con los colores y movimientos esperados.  
- Prob√© que al cambiar de estado, el movimiento se ajustara de inmediato sin errores ni comportamientos raros.  
- Tambi√©n prob√© que las teclas respondieran correctamente (C, A, X, M, 1‚Äì6 y el clic del mouse).

Despu√©s de ajustar varios detalles, logr√© que el proyecto fuera fluido, estable y visualmente atractivo.

---

# **Evidencias**

### **C√ìDIGOS**

- **C√≥digo fuente:**

of.App.h:
¬¥¬¥¬¥
#pragma once
#include "ofMain.h"

// ========================== OBSERVER ==========================
class Observer {
public:
    virtual void onNotify(string state) = 0;
};

// ========================== SUBJECT ==========================
class Subject {
    vector<Observer*> observers;
public:
    void addObserver(Observer* obs) {
        observers.push_back(obs);
    }
    void notify(string state) {
        for (auto& obs : observers) {
            obs->onNotify(state);
        }
    }
};

// ========================== CIRCLE BASE CLASS ==========================
class CircleBase : public Observer {
public:
    ofVec2f pos;
    ofVec2f vel;
    float radius;
    ofColor color;

    CircleBase(ofVec2f _pos, float _radius, ofColor _color)
        : pos(_pos), radius(_radius), color(_color) {
        vel.set(ofRandom(-1, 1), ofRandom(-1, 1));
    }

    virtual void update() = 0;
    virtual void draw() = 0;
};

// ========================== TIPOS DE C√çRCULOS ==========================

// ---- SimpleCircle ----
class SimpleCircle : public CircleBase {
public:
    int colorIndex = 0;
    vector<ofColor> calmPalette = {
        ofColor::aqua, ofColor::purple,
        ofColor(0, 255, 0), ofColor(0, 100, 0)
    };

    SimpleCircle(ofVec2f p)
        : CircleBase(p, ofRandom(8, 60), ofColor::aqua) {
    }

    void update() override {
        pos += vel;
        if (pos.x < 0 || pos.x > ofGetWidth()) vel.x *= -1;
        if (pos.y < 0 || pos.y > ofGetHeight()) vel.y *= -1;
    }

    void draw() override {
        ofSetColor(color);
        ofDrawCircle(pos, radius);
    }

    void onNotify(string state) override {
        if (state == "CALM") color = ofColor::aqua;
        else if (state == "ACTIVE") color = ofColor::yellow;
        else if (state == "CHAOS") color = ofColor::red;
        else if (state == "COLOR_TOGGLE") {
            colorIndex = (colorIndex + 1) % calmPalette.size();
            color = calmPalette[colorIndex];
        }
    }
};

// ---- PulsingCircle ----
class PulsingCircle : public CircleBase {
public:
    int colorIndex = 0;
    vector<ofColor> calmPalette = {
        ofColor::aqua, ofColor::purple,
        ofColor(0, 255, 0), ofColor(0, 100, 0)
    };

    PulsingCircle(ofVec2f p)
        : CircleBase(p, ofRandom(15, 70), ofColor::purple) {
    }

    void update() override {
        pos += vel;
        if (pos.x < 0 || pos.x > ofGetWidth()) vel.x *= -1;
        if (pos.y < 0 || pos.y > ofGetHeight()) vel.y *= -1;
    }

    void draw() override {
        ofSetColor(color);
        ofDrawCircle(pos, radius);
    }

    void onNotify(string state) override {
        if (state == "CALM") color = ofColor::blueViolet;
        else if (state == "ACTIVE") color = ofColor::orange;
        else if (state == "CHAOS") color = ofColor::crimson;
        else if (state == "COLOR_TOGGLE") {
            colorIndex = (colorIndex + 1) % calmPalette.size();
            color = calmPalette[colorIndex];
        }
    }
};

// ========================== FACTORY ==========================
class CircleFactory {
public:
    static CircleBase* create(string type, ofVec2f pos) {
        if (type == "simple") return new SimpleCircle(pos);
        else if (type == "pulsing") return new PulsingCircle(pos);
        else return nullptr;
    }
};

// ========================== STATE ==========================
class State {
public:
    virtual string getName() = 0;
    virtual void apply(vector<CircleBase*>& circles) = 0;
};

class CalmState : public State {
public:
    string getName() override { return "CALM"; }
    void apply(vector<CircleBase*>& circles) override {
        for (auto& c : circles) {
            c->vel += ofVec2f(ofRandom(-0.01, 0.01), ofRandom(-0.01, 0.01));
            c->vel.limit(0.5);
        }
    }
};

class ActiveState : public State {
public:
    string getName() override { return "ACTIVE"; }
    void apply(vector<CircleBase*>& circles) override {
        for (auto& c : circles) {
            c->vel += ofVec2f(ofRandom(-0.8, 0.8), ofRandom(-0.8, 0.8));
            c->vel.limit(4);
        }
    }
};

class ChaosState : public State {
public:
    string getName() override { return "CHAOS"; }
    void apply(vector<CircleBase*>& circles) override {
        for (auto& c : circles) {
            float shakeX = ofRandom(-10, 10);
            float shakeY = ofRandom(-10, 10);
            c->pos.x += shakeX;
            c->pos.y += shakeY;
            c->vel += ofVec2f(ofRandom(-1.5, 1.5), ofRandom(-1.5, 1.5));
            c->vel.limit(8);
        }
    }
};

// ========================== MAIN APP ==========================
class ofApp : public ofBaseApp, public Subject {

public:
    void setup();
    void update();
    void draw();
    void keyPressed(int key);
    void mousePressed(int x, int y, int button);

    vector<CircleBase*> circles;
    State* currentState;
    CalmState calm;
    ActiveState active;
    ChaosState chaos;

    void changeState(State* newState);
    void randomizePositions();

    // --- NUEVO BLOQUE PARA MANEJO DE VELOCIDADES ---
    int currentSpeedLevel = 1;
    float speedMultiplier = 1.0;

    void updateSpeedLevel(int level) {
        currentSpeedLevel = level;
        switch (level) {
        case 1: speedMultiplier = 0.5; break;
        case 2: speedMultiplier = 0.8; break;
        case 3: speedMultiplier = 1.0; break;
        case 4: speedMultiplier = 1.3; break;
        case 5: speedMultiplier = 1.6; break;
        case 6:
            speedMultiplier = 2.0;
            currentState = &chaos;
            notify("CHAOS");
            break;
        }
        notify("SPEED_CHANGED");
    }
};
¬¥¬¥¬¥

ofApp.cpp:
¬¥¬¥¬¥
#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup() {
    ofSetFrameRate(60);
    ofBackground(10);
    ofSetCircleResolution(50);

    // Estado inicial
    currentState = &calm;

    // Crear c√≠rculos mediante la Factory
    for (int i = 0; i < 60; i++) {
        string type = (ofRandom(1) > 0.5) ? "simple" : "pulsing";
        ofVec2f pos(ofRandomWidth(), ofRandomHeight());
        CircleBase* c = CircleFactory::create(type, pos);
        addObserver(c);
        circles.push_back(c);
    }

    notify(currentState->getName());
}

//--------------------------------------------------------------
void ofApp::update() {
    currentState->apply(circles);
    for (auto& c : circles) {
        c->pos += c->vel * speedMultiplier;
    }
}

//--------------------------------------------------------------
void ofApp::draw() {
    for (auto& c : circles) c->draw();

    ofSetColor(255);
    ofDrawBitmapStringHighlight("State: " + currentState->getName(), 20, 20);
    ofDrawBitmapStringHighlight("Speed level: " + ofToString(currentSpeedLevel), 20, 40);
    ofDrawBitmapStringHighlight("C: Calm | A: Active | X: Chaos", 20, 60);
    ofDrawBitmapStringHighlight("M (solo en CALM): Alternar color", 20, 80);
    ofDrawBitmapStringHighlight("1‚Äì6: Speed levels | Click: Randomize", 20, 100);
}

//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
    // Cambiar estado con teclas C, A, X
    if (key == 'c' || key == 'C') changeState(&calm);
    else if (key == 'a' || key == 'A') changeState(&active);
    else if (key == 'x' || key == 'X') changeState(&chaos);

    // Control de velocidades con teclas 1‚Äì6
    if (key >= '1' && key <= '6') {
        int level = key - '0';
        updateSpeedLevel(level);
    }

    // --- CAMBIO DE COLOR SOLO EN MODO CALM ---
    if ((key == 'm' || key == 'M') && currentState == &calm) {
        notify("COLOR_TOGGLE");
    }
}

//--------------------------------------------------------------
void ofApp::mousePressed(int x, int y, int button) {
    if (button == OF_MOUSE_BUTTON_LEFT) {
        randomizePositions();
    }
}

//--------------------------------------------------------------
void ofApp::randomizePositions() {
    for (auto& c : circles) {
        c->pos.set(ofRandomWidth(), ofRandomHeight());
        c->vel.set(ofRandom(-1, 1), ofRandom(-1, 1));
    }
}

//--------------------------------------------------------------
void ofApp::changeState(State* newState) {
    currentState = newState;
    notify(currentState->getName());
}
¬¥¬¥¬¥

---

### **Validaci√≥n de los resultados de aprendizaje**

#### **RAE1: Construcci√≥n de la aplicaci√≥n**
La aplicaci√≥n cumple con los requisitos funcionales al integrar los tres patrones de dise√±o de forma coherente:
- **Observer**: sincroniza el comportamiento de todos los c√≠rculos ante los eventos globales.
- **Factory**: genera distintos tipos de c√≠rculos con caracter√≠sticas visuales y din√°micas √∫nicas.
- **State**: controla los modos del sistema y la energ√≠a general de la composici√≥n.

Esto permite que el proyecto sea modular, escalable y con un comportamiento interactivo fluido.

#### **RAE2: Pruebas del software**
Durante las pruebas, confirm√© tanto el funcionamiento individual como la integraci√≥n de los tres patrones:
- Al cambiar el **estado** (State), verifiqu√© que los c√≠rculos creados por distintas f√°bricas respondieran correctamente al evento de cambio (Observer).
- Prob√© que las notificaciones globales no generaran duplicaci√≥n ni errores de referencia.
- Revis√© que el rendimiento se mantuviera estable incluso con muchos c√≠rculos activos.
- Valid√© que las teclas y eventos del mouse siguieran funcionando correctamente tras m√∫ltiples transiciones entre estados.

El resultado fue un comportamiento consistente, con transiciones suaves y sin conflictos entre los patrones implementados.

---

### **üìΩÔ∏è Video demostrativo**



