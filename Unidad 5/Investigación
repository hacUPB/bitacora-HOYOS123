# Unidad 5
---
### ¿Qué representa la clase `Particle`?
La clase `Particle` es un **molde** para crear partículas.  
- Define **datos**: `x` y `y` (posición).  
- Define **acciones**: `move()` (mover la partícula).  

---
### ¿Cómo interactúan sus atributos y métodos?
- Los **atributos** (`x` y `y`) guardan la posición de la partícula.  
- El **método** `move(dx, dy)` cambia esos valores, actualizando la posición.

---
### ¿Qué es un objeto en C++ y cómo se relaciona con una clase?
- Una **clase** es como un molde o plano (define qué datos y qué acciones existen).  
- Un **objeto** es una instancia real creada a partir de esa clase.

---
### Explorando la memoria en C++
- Cada **objeto** ocupa su propio espacio en memoria.  
- Dos instancias (`p1` y `p2`) tienen direcciones diferentes, aunque sean del mismo tipo.  
- Los **atributos** (`x` y `y`) de un mismo objeto suelen estar almacenados de forma contigua.  
- El **sizeof(Particle)** muestra cuántos bytes ocupa la clase en memoria (la suma de sus atributos, considerando alineación).

---
### Análisis de diferencias en memoria

- **Clases simples vs complejas**:  
  - `Simple` con un solo atributo ocupa pocos bytes.  
  - `Complex`, aunque tenga más métodos, el tamaño solo depende de los atributos, no de los métodos.  

- **Datos estáticos**:  
  - Una variable `static` pertenece a la **clase**, no a cada objeto.  
  - Por eso, no aumenta el tamaño de las instancias.  
  - Ejemplo: en `StaticData`, el atributo `s` no cuenta dentro de `sizeof(StaticData)`.  

- **Datos dinámicos**:  
  - En `DynamicData`, el atributo `ptr` es solo un **puntero**, por lo que ocupa lo mismo que un puntero (4 u 8 bytes, según la arquitectura).  
  - La memoria real del arreglo (`new int[10]`) se guarda en el **heap**, no dentro del objeto.  
  - Por eso, el tamaño del objeto no cambia, pero sí la memoria total que consume el programa.

  ### Reflexión

- **Un objeto en memoria**:  
  Es un bloque de memoria que contiene sus atributos. Según cómo se cree, puede estar en el **stack** (si es automático) o en el **heap** (si se usa `new`).  

- **Atributos y métodos**:  
  - Los **atributos** influyen directamente en el tamaño del objeto (`sizeof`).  
  - Los **métodos** no aumentan el tamaño del objeto, porque el código se guarda en otra sección de la memoria (sección de texto/código).  
  - Si hay **punteros dinámicos**, el objeto guarda solo la dirección, mientras que la memoria real se reserva en el heap.  

- **Conclusión**:  
  El diseño de clases debe balancear el uso de atributos normales, estáticos y dinámicos, ya que cada uno impacta distinto la memoria. Entender dónde vive cada parte ayuda a evitar fugas de memoria y a optimizar el rendimiento.

---
### Sesión 2: ubicación en memoria de datos y métodos

**Objetivo**: comprender cómo se organizan los objetos en memoria.

- **Datos (atributos)**:  
  - En el **stack** si el objeto es local.  
  - En el **heap** si se crea dinámicamente con `new`.  

- **Métodos**:  
  - El código de los métodos se guarda en la **sección de texto** (programa ejecutable).  
  - No aumentan el tamaño de las instancias.  

- **Vtables (tablas virtuales)**:  
  - Cuando una clase tiene métodos `virtual`, el compilador crea una **vtable**: una tabla interna con punteros a las implementaciones de esos métodos.  
  - Cada objeto de una clase con métodos virtuales guarda un puntero oculto a su vtable.  
  - Esto permite el **polimorfismo dinámico**, es decir, decidir en tiempo de ejecución qué método llamar.  